package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContainerMock implements deduplicator.container
type ContainerMock struct {
	t minimock.Tester

	funcCalculate          func(ctx context.Context, input int) (i1 int, err error)
	inspectFuncCalculate   func(ctx context.Context, input int)
	afterCalculateCounter  uint64
	beforeCalculateCounter uint64
	CalculateMock          mContainerMockCalculate

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mContainerMockClose
}

// NewContainerMock returns a mock for deduplicator.container
func NewContainerMock(t minimock.Tester) *ContainerMock {
	m := &ContainerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CalculateMock = mContainerMockCalculate{mock: m}
	m.CalculateMock.callArgs = []*ContainerMockCalculateParams{}

	m.CloseMock = mContainerMockClose{mock: m}

	return m
}

type mContainerMockCalculate struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockCalculateExpectation
	expectations       []*ContainerMockCalculateExpectation

	callArgs []*ContainerMockCalculateParams
	mutex    sync.RWMutex
}

// ContainerMockCalculateExpectation specifies expectation struct of the container.Calculate
type ContainerMockCalculateExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockCalculateParams
	results *ContainerMockCalculateResults
	Counter uint64
}

// ContainerMockCalculateParams contains parameters of the container.Calculate
type ContainerMockCalculateParams struct {
	ctx   context.Context
	input int
}

// ContainerMockCalculateResults contains results of the container.Calculate
type ContainerMockCalculateResults struct {
	i1  int
	err error
}

// Expect sets up expected params for container.Calculate
func (mmCalculate *mContainerMockCalculate) Expect(ctx context.Context, input int) *mContainerMockCalculate {
	if mmCalculate.mock.funcCalculate != nil {
		mmCalculate.mock.t.Fatalf("ContainerMock.Calculate mock is already set by Set")
	}

	if mmCalculate.defaultExpectation == nil {
		mmCalculate.defaultExpectation = &ContainerMockCalculateExpectation{}
	}

	mmCalculate.defaultExpectation.params = &ContainerMockCalculateParams{ctx, input}
	for _, e := range mmCalculate.expectations {
		if minimock.Equal(e.params, mmCalculate.defaultExpectation.params) {
			mmCalculate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCalculate.defaultExpectation.params)
		}
	}

	return mmCalculate
}

// Inspect accepts an inspector function that has same arguments as the container.Calculate
func (mmCalculate *mContainerMockCalculate) Inspect(f func(ctx context.Context, input int)) *mContainerMockCalculate {
	if mmCalculate.mock.inspectFuncCalculate != nil {
		mmCalculate.mock.t.Fatalf("Inspect function is already set for ContainerMock.Calculate")
	}

	mmCalculate.mock.inspectFuncCalculate = f

	return mmCalculate
}

// Return sets up results that will be returned by container.Calculate
func (mmCalculate *mContainerMockCalculate) Return(i1 int, err error) *ContainerMock {
	if mmCalculate.mock.funcCalculate != nil {
		mmCalculate.mock.t.Fatalf("ContainerMock.Calculate mock is already set by Set")
	}

	if mmCalculate.defaultExpectation == nil {
		mmCalculate.defaultExpectation = &ContainerMockCalculateExpectation{mock: mmCalculate.mock}
	}
	mmCalculate.defaultExpectation.results = &ContainerMockCalculateResults{i1, err}
	return mmCalculate.mock
}

//Set uses given function f to mock the container.Calculate method
func (mmCalculate *mContainerMockCalculate) Set(f func(ctx context.Context, input int) (i1 int, err error)) *ContainerMock {
	if mmCalculate.defaultExpectation != nil {
		mmCalculate.mock.t.Fatalf("Default expectation is already set for the container.Calculate method")
	}

	if len(mmCalculate.expectations) > 0 {
		mmCalculate.mock.t.Fatalf("Some expectations are already set for the container.Calculate method")
	}

	mmCalculate.mock.funcCalculate = f
	return mmCalculate.mock
}

// When sets expectation for the container.Calculate which will trigger the result defined by the following
// Then helper
func (mmCalculate *mContainerMockCalculate) When(ctx context.Context, input int) *ContainerMockCalculateExpectation {
	if mmCalculate.mock.funcCalculate != nil {
		mmCalculate.mock.t.Fatalf("ContainerMock.Calculate mock is already set by Set")
	}

	expectation := &ContainerMockCalculateExpectation{
		mock:   mmCalculate.mock,
		params: &ContainerMockCalculateParams{ctx, input},
	}
	mmCalculate.expectations = append(mmCalculate.expectations, expectation)
	return expectation
}

// Then sets up container.Calculate return parameters for the expectation previously defined by the When method
func (e *ContainerMockCalculateExpectation) Then(i1 int, err error) *ContainerMock {
	e.results = &ContainerMockCalculateResults{i1, err}
	return e.mock
}

// Calculate implements deduplicator.container
func (mmCalculate *ContainerMock) Calculate(ctx context.Context, input int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCalculate.beforeCalculateCounter, 1)
	defer mm_atomic.AddUint64(&mmCalculate.afterCalculateCounter, 1)

	if mmCalculate.inspectFuncCalculate != nil {
		mmCalculate.inspectFuncCalculate(ctx, input)
	}

	mm_params := &ContainerMockCalculateParams{ctx, input}

	// Record call args
	mmCalculate.CalculateMock.mutex.Lock()
	mmCalculate.CalculateMock.callArgs = append(mmCalculate.CalculateMock.callArgs, mm_params)
	mmCalculate.CalculateMock.mutex.Unlock()

	for _, e := range mmCalculate.CalculateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCalculate.CalculateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCalculate.CalculateMock.defaultExpectation.Counter, 1)
		mm_want := mmCalculate.CalculateMock.defaultExpectation.params
		mm_got := ContainerMockCalculateParams{ctx, input}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCalculate.t.Errorf("ContainerMock.Calculate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCalculate.CalculateMock.defaultExpectation.results
		if mm_results == nil {
			mmCalculate.t.Fatal("No results are set for the ContainerMock.Calculate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCalculate.funcCalculate != nil {
		return mmCalculate.funcCalculate(ctx, input)
	}
	mmCalculate.t.Fatalf("Unexpected call to ContainerMock.Calculate. %v %v", ctx, input)
	return
}

// CalculateAfterCounter returns a count of finished ContainerMock.Calculate invocations
func (mmCalculate *ContainerMock) CalculateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalculate.afterCalculateCounter)
}

// CalculateBeforeCounter returns a count of ContainerMock.Calculate invocations
func (mmCalculate *ContainerMock) CalculateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalculate.beforeCalculateCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.Calculate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCalculate *mContainerMockCalculate) Calls() []*ContainerMockCalculateParams {
	mmCalculate.mutex.RLock()

	argCopy := make([]*ContainerMockCalculateParams, len(mmCalculate.callArgs))
	copy(argCopy, mmCalculate.callArgs)

	mmCalculate.mutex.RUnlock()

	return argCopy
}

// MinimockCalculateDone returns true if the count of the Calculate invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockCalculateDone() bool {
	for _, e := range m.CalculateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalculateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalculate != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCalculateInspect logs each unmet expectation
func (m *ContainerMock) MinimockCalculateInspect() {
	for _, e := range m.CalculateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.Calculate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalculateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		if m.CalculateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.Calculate")
		} else {
			m.t.Errorf("Expected call to ContainerMock.Calculate with params: %#v", *m.CalculateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalculate != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.Calculate")
	}
}

type mContainerMockClose struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockCloseExpectation
	expectations       []*ContainerMockCloseExpectation
}

// ContainerMockCloseExpectation specifies expectation struct of the container.Close
type ContainerMockCloseExpectation struct {
	mock *ContainerMock

	results *ContainerMockCloseResults
	Counter uint64
}

// ContainerMockCloseResults contains results of the container.Close
type ContainerMockCloseResults struct {
	err error
}

// Expect sets up expected params for container.Close
func (mmClose *mContainerMockClose) Expect() *mContainerMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ContainerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ContainerMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the container.Close
func (mmClose *mContainerMockClose) Inspect(f func()) *mContainerMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ContainerMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by container.Close
func (mmClose *mContainerMockClose) Return(err error) *ContainerMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ContainerMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ContainerMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ContainerMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the container.Close method
func (mmClose *mContainerMockClose) Set(f func() (err error)) *ContainerMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the container.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the container.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements deduplicator.container
func (mmClose *ContainerMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ContainerMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ContainerMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ContainerMock.Close invocations
func (mmClose *ContainerMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ContainerMock.Close invocations
func (mmClose *ContainerMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ContainerMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ContainerMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.Close")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContainerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCalculateInspect()

		m.MinimockCloseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContainerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContainerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCalculateDone() &&
		m.MinimockCloseDone()
}
