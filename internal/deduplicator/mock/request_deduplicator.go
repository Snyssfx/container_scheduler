package mock

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RequestDeduplicatorMock implements deduplicator.requestDeduplicator
type RequestDeduplicatorMock struct {
	t minimock.Tester

	funcCalculate          func(ctx context.Context, input int) (i1 int, err error)
	inspectFuncCalculate   func(ctx context.Context, input int)
	afterCalculateCounter  uint64
	beforeCalculateCounter uint64
	CalculateMock          mRequestDeduplicatorMockCalculate

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mRequestDeduplicatorMockClose
}

// NewRequestDeduplicatorMock returns a mock for deduplicator.requestDeduplicator
func NewRequestDeduplicatorMock(t minimock.Tester) *RequestDeduplicatorMock {
	m := &RequestDeduplicatorMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CalculateMock = mRequestDeduplicatorMockCalculate{mock: m}
	m.CalculateMock.callArgs = []*RequestDeduplicatorMockCalculateParams{}

	m.CloseMock = mRequestDeduplicatorMockClose{mock: m}

	return m
}

type mRequestDeduplicatorMockCalculate struct {
	mock               *RequestDeduplicatorMock
	defaultExpectation *RequestDeduplicatorMockCalculateExpectation
	expectations       []*RequestDeduplicatorMockCalculateExpectation

	callArgs []*RequestDeduplicatorMockCalculateParams
	mutex    sync.RWMutex
}

// RequestDeduplicatorMockCalculateExpectation specifies expectation struct of the requestDeduplicator.Calculate
type RequestDeduplicatorMockCalculateExpectation struct {
	mock    *RequestDeduplicatorMock
	params  *RequestDeduplicatorMockCalculateParams
	results *RequestDeduplicatorMockCalculateResults
	Counter uint64
}

// RequestDeduplicatorMockCalculateParams contains parameters of the requestDeduplicator.Calculate
type RequestDeduplicatorMockCalculateParams struct {
	ctx   context.Context
	input int
}

// RequestDeduplicatorMockCalculateResults contains results of the requestDeduplicator.Calculate
type RequestDeduplicatorMockCalculateResults struct {
	i1  int
	err error
}

// Expect sets up expected params for requestDeduplicator.Calculate
func (mmCalculate *mRequestDeduplicatorMockCalculate) Expect(ctx context.Context, input int) *mRequestDeduplicatorMockCalculate {
	if mmCalculate.mock.funcCalculate != nil {
		mmCalculate.mock.t.Fatalf("RequestDeduplicatorMock.Calculate mock is already set by Set")
	}

	if mmCalculate.defaultExpectation == nil {
		mmCalculate.defaultExpectation = &RequestDeduplicatorMockCalculateExpectation{}
	}

	mmCalculate.defaultExpectation.params = &RequestDeduplicatorMockCalculateParams{ctx, input}
	for _, e := range mmCalculate.expectations {
		if minimock.Equal(e.params, mmCalculate.defaultExpectation.params) {
			mmCalculate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCalculate.defaultExpectation.params)
		}
	}

	return mmCalculate
}

// Inspect accepts an inspector function that has same arguments as the requestDeduplicator.Calculate
func (mmCalculate *mRequestDeduplicatorMockCalculate) Inspect(f func(ctx context.Context, input int)) *mRequestDeduplicatorMockCalculate {
	if mmCalculate.mock.inspectFuncCalculate != nil {
		mmCalculate.mock.t.Fatalf("Inspect function is already set for RequestDeduplicatorMock.Calculate")
	}

	mmCalculate.mock.inspectFuncCalculate = f

	return mmCalculate
}

// Return sets up results that will be returned by requestDeduplicator.Calculate
func (mmCalculate *mRequestDeduplicatorMockCalculate) Return(i1 int, err error) *RequestDeduplicatorMock {
	if mmCalculate.mock.funcCalculate != nil {
		mmCalculate.mock.t.Fatalf("RequestDeduplicatorMock.Calculate mock is already set by Set")
	}

	if mmCalculate.defaultExpectation == nil {
		mmCalculate.defaultExpectation = &RequestDeduplicatorMockCalculateExpectation{mock: mmCalculate.mock}
	}
	mmCalculate.defaultExpectation.results = &RequestDeduplicatorMockCalculateResults{i1, err}
	return mmCalculate.mock
}

//Set uses given function f to mock the requestDeduplicator.Calculate method
func (mmCalculate *mRequestDeduplicatorMockCalculate) Set(f func(ctx context.Context, input int) (i1 int, err error)) *RequestDeduplicatorMock {
	if mmCalculate.defaultExpectation != nil {
		mmCalculate.mock.t.Fatalf("Default expectation is already set for the requestDeduplicator.Calculate method")
	}

	if len(mmCalculate.expectations) > 0 {
		mmCalculate.mock.t.Fatalf("Some expectations are already set for the requestDeduplicator.Calculate method")
	}

	mmCalculate.mock.funcCalculate = f
	return mmCalculate.mock
}

// When sets expectation for the requestDeduplicator.Calculate which will trigger the result defined by the following
// Then helper
func (mmCalculate *mRequestDeduplicatorMockCalculate) When(ctx context.Context, input int) *RequestDeduplicatorMockCalculateExpectation {
	if mmCalculate.mock.funcCalculate != nil {
		mmCalculate.mock.t.Fatalf("RequestDeduplicatorMock.Calculate mock is already set by Set")
	}

	expectation := &RequestDeduplicatorMockCalculateExpectation{
		mock:   mmCalculate.mock,
		params: &RequestDeduplicatorMockCalculateParams{ctx, input},
	}
	mmCalculate.expectations = append(mmCalculate.expectations, expectation)
	return expectation
}

// Then sets up requestDeduplicator.Calculate return parameters for the expectation previously defined by the When method
func (e *RequestDeduplicatorMockCalculateExpectation) Then(i1 int, err error) *RequestDeduplicatorMock {
	e.results = &RequestDeduplicatorMockCalculateResults{i1, err}
	return e.mock
}

// Calculate implements deduplicator.requestDeduplicator
func (mmCalculate *RequestDeduplicatorMock) Calculate(ctx context.Context, input int) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCalculate.beforeCalculateCounter, 1)
	defer mm_atomic.AddUint64(&mmCalculate.afterCalculateCounter, 1)

	if mmCalculate.inspectFuncCalculate != nil {
		mmCalculate.inspectFuncCalculate(ctx, input)
	}

	mm_params := &RequestDeduplicatorMockCalculateParams{ctx, input}

	// Record call args
	mmCalculate.CalculateMock.mutex.Lock()
	mmCalculate.CalculateMock.callArgs = append(mmCalculate.CalculateMock.callArgs, mm_params)
	mmCalculate.CalculateMock.mutex.Unlock()

	for _, e := range mmCalculate.CalculateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCalculate.CalculateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCalculate.CalculateMock.defaultExpectation.Counter, 1)
		mm_want := mmCalculate.CalculateMock.defaultExpectation.params
		mm_got := RequestDeduplicatorMockCalculateParams{ctx, input}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCalculate.t.Errorf("RequestDeduplicatorMock.Calculate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCalculate.CalculateMock.defaultExpectation.results
		if mm_results == nil {
			mmCalculate.t.Fatal("No results are set for the RequestDeduplicatorMock.Calculate")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCalculate.funcCalculate != nil {
		return mmCalculate.funcCalculate(ctx, input)
	}
	mmCalculate.t.Fatalf("Unexpected call to RequestDeduplicatorMock.Calculate. %v %v", ctx, input)
	return
}

// CalculateAfterCounter returns a count of finished RequestDeduplicatorMock.Calculate invocations
func (mmCalculate *RequestDeduplicatorMock) CalculateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalculate.afterCalculateCounter)
}

// CalculateBeforeCounter returns a count of RequestDeduplicatorMock.Calculate invocations
func (mmCalculate *RequestDeduplicatorMock) CalculateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCalculate.beforeCalculateCounter)
}

// Calls returns a list of arguments used in each call to RequestDeduplicatorMock.Calculate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCalculate *mRequestDeduplicatorMockCalculate) Calls() []*RequestDeduplicatorMockCalculateParams {
	mmCalculate.mutex.RLock()

	argCopy := make([]*RequestDeduplicatorMockCalculateParams, len(mmCalculate.callArgs))
	copy(argCopy, mmCalculate.callArgs)

	mmCalculate.mutex.RUnlock()

	return argCopy
}

// MinimockCalculateDone returns true if the count of the Calculate invocations corresponds
// the number of defined expectations
func (m *RequestDeduplicatorMock) MinimockCalculateDone() bool {
	for _, e := range m.CalculateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalculateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalculate != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCalculateInspect logs each unmet expectation
func (m *RequestDeduplicatorMock) MinimockCalculateInspect() {
	for _, e := range m.CalculateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RequestDeduplicatorMock.Calculate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CalculateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		if m.CalculateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RequestDeduplicatorMock.Calculate")
		} else {
			m.t.Errorf("Expected call to RequestDeduplicatorMock.Calculate with params: %#v", *m.CalculateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCalculate != nil && mm_atomic.LoadUint64(&m.afterCalculateCounter) < 1 {
		m.t.Error("Expected call to RequestDeduplicatorMock.Calculate")
	}
}

type mRequestDeduplicatorMockClose struct {
	mock               *RequestDeduplicatorMock
	defaultExpectation *RequestDeduplicatorMockCloseExpectation
	expectations       []*RequestDeduplicatorMockCloseExpectation
}

// RequestDeduplicatorMockCloseExpectation specifies expectation struct of the requestDeduplicator.Close
type RequestDeduplicatorMockCloseExpectation struct {
	mock *RequestDeduplicatorMock

	results *RequestDeduplicatorMockCloseResults
	Counter uint64
}

// RequestDeduplicatorMockCloseResults contains results of the requestDeduplicator.Close
type RequestDeduplicatorMockCloseResults struct {
	err error
}

// Expect sets up expected params for requestDeduplicator.Close
func (mmClose *mRequestDeduplicatorMockClose) Expect() *mRequestDeduplicatorMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RequestDeduplicatorMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RequestDeduplicatorMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the requestDeduplicator.Close
func (mmClose *mRequestDeduplicatorMockClose) Inspect(f func()) *mRequestDeduplicatorMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for RequestDeduplicatorMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by requestDeduplicator.Close
func (mmClose *mRequestDeduplicatorMockClose) Return(err error) *RequestDeduplicatorMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("RequestDeduplicatorMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &RequestDeduplicatorMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &RequestDeduplicatorMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the requestDeduplicator.Close method
func (mmClose *mRequestDeduplicatorMockClose) Set(f func() (err error)) *RequestDeduplicatorMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the requestDeduplicator.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the requestDeduplicator.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements deduplicator.requestDeduplicator
func (mmClose *RequestDeduplicatorMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the RequestDeduplicatorMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to RequestDeduplicatorMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished RequestDeduplicatorMock.Close invocations
func (mmClose *RequestDeduplicatorMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of RequestDeduplicatorMock.Close invocations
func (mmClose *RequestDeduplicatorMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *RequestDeduplicatorMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *RequestDeduplicatorMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to RequestDeduplicatorMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to RequestDeduplicatorMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to RequestDeduplicatorMock.Close")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RequestDeduplicatorMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCalculateInspect()

		m.MinimockCloseInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RequestDeduplicatorMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RequestDeduplicatorMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCalculateDone() &&
		m.MinimockCloseDone()
}
